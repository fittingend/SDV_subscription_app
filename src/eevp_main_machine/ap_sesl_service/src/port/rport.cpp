///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : rport.cpp
/// SOFTWARE COMPONENT NAME           : RPort
/// GENERATED DATE                    : 2024-11-15 21:01:32
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "port/rport.h"

namespace sesl_executable
{
    namespace rootswcomponent
    {
        namespace port
        {
            RPort::RPort()
                : mLogger(ara::log::CreateLogger("RPRT", "RPRT", ara::log::LogLevel::kVerbose)),
                  mProxy{nullptr},
                  mHandle{},
                  cvHandle{}
            {
                mLogger.LogInfo() << __func__;
            }

            RPort::~RPort()
            {
                if (mProxy)
                {
                    mProxy->StopFindService(*mFindHandle);
                    mProxy.reset();
                }
            }

            bool RPort::Initialize()
            {
                this->send_Data.Fwd_Distance = 0;
                this->send_Data.Rear_Distance = 0;
                this->send_Data.Accel = false;
                this->send_Data.Brake = 0;
                this->send_Data.Beep = false;
                this->send_Data.Beep_Large = false;
                this->send_Data.Light = 0;

                this->receive_Data.Fwd_Distance = 0;
                this->receive_Data.Rear_Distance = 0;
                this->receive_Data.Accel = false;
                this->receive_Data.Brake = 0;
                this->receive_Data.Beep = false;
                this->receive_Data.Beep_Large = false;
                this->receive_Data.Light = 0;
            }

            bool RPort::Start()
            {
                // mLogger.LogVerbose() << __func__;

                // regist callback
                ara::core::InstanceSpecifier specifier{"SESLService/AA/RPort_SESLService"};

                auto callback = [&](auto container, auto findHandle)
                {
                    FindServiceCallback(container, findHandle);
                };

                std::unique_lock<std::mutex> lock(mHandle);

                auto result = ara::com::proxy::SESL_ServiceInterfaceProxy::StartFindService(callback, specifier);

                if (cvHandle.wait_for(lock, std::chrono::milliseconds(1000)) == std::cv_status::timeout)
                {
                    // mLogger.LogInfo() << "cvHandle is empty";
                    return false;
                }

                if (!result.HasValue())
                {
                    // mLogger.LogInfo() << "RPort StartFindService() Failed";
                    return false;
                }
                else
                {
                    mLogger.LogInfo() << "RPort StartFindService() Success";
                }

                return true;
            }

            void RPort::RequestSESL_Receive()
            {
                // mLogger.LogInfo() << __func__;

                auto request = mProxy->SESL_Receive();
                request.wait();
                auto result = request.GetResult();

                if (result.HasValue())
                {
                    // mLogger.LogVerbose() << "RPort::RequestSESL_Receive::Responded";

                    auto value = result.Value();
                    this->receive_Data = value.Receive_Argument;
                    SESL_Logic();
                    RequestSESL_Send(this->send_Data);
                    return;
                }
                else
                {
                    mLogger.LogError() << "RPort::RequestSESL_Receive::" << result.Error().Message();
                }
            }

            void RPort::RequestSESL_Send(const ara::SESL::Vehicle_Data &Send_Argument)
            {
                mProxy->SESL_Send(Send_Argument);
                return;
            }

            void RPort::SESL_Logic()
            {
                // 제어 Logic
                // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

                bool rtb_Compare;
                bool rtb_or_logic;

                this->send_Data.Accel = (this->receive_Data.Fwd_Distance <= 3.0);
                rtb_Compare = (this->receive_Data.Rear_Distance <= 3.0);
                rtb_or_logic = (this->send_Data.Accel || rtb_Compare);

                this->send_Data.Beep_Large = rtb_or_logic;
                this->send_Data.Beep = ((this->receive_Data.Fwd_Distance <= 5.0) && (this->receive_Data.Rear_Distance >= 3.0));

                if (this->send_Data.Beep)
                {
                    this->send_Data.Brake = 1.0;
                }
                else
                {
                    this->send_Data.Brake = 0.0;
                }

                this->send_Data.Light = this->send_Data.Beep;
                this->send_Data.Beep = (this->receive_Data.Fwd_Distance <= 7.0);
                this->send_Data.Accel = (this->send_Data.Accel && (!rtb_Compare));

                /*
                { // Sample time: [0.3s, 0.0s]
                    if ((rtmGetTFinal(Control_M) != -1) &&
                        !((rtmGetTFinal(Control_M) - Control_M->Timing.taskTime0) >
                          Control_M->Timing.taskTime0 * (DBL_EPSILON)))
                    {
                        rtmSetErrorStatus(Control_M, "Simulation finished");
                    }
                }

                Control_M->Timing.taskTime0 =
                    ((time_T)(++Control_M->Timing.clockTick0)) * Control_M->Timing.stepSize0;
                */

                // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            }

            void
            RPort::FindServiceCallback(
                ara::com::ServiceHandleContainer<ara::com::proxy::SESL_ServiceInterfaceProxy::HandleType> container,
                ara::com::FindServiceHandle findHandle)
            {
                mLogger.LogInfo() << __func__;

                std::lock_guard<std::mutex> lock(mHandle);

                int size = container.size();
                mLogger.LogInfo() << "sesl container size = " << size;

                if (mProxy != nullptr)
                {
                    mFindHandle = nullptr;
                    mProxy = nullptr;
                }

                if (container.empty())
                {
                    mLogger.LogWarn() << __func__ << "container empty";
                    mProxy = nullptr;
                    return;
                }

                mFindHandle = std::make_shared<ara::com::FindServiceHandle>(findHandle);
                mProxy = std::make_shared<ara::com::proxy::SESL_ServiceInterfaceProxy>(container.at(0));

                cvHandle.notify_one();
                mLogger.LogInfo() << "Find Service complete";
            }

        } /// namespace port
    } /// namespace rootswcomponent
} /// namespace sesl_executable

/// EOF
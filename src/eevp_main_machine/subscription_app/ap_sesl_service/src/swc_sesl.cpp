///////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : swc_sesl.cpp
/// SOFTWARE COMPONENT NAME           : SWC_SESL
/// GENERATED DATE                    : 2024-11-15 21:01:32
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "swc_sesl.h"

namespace sesl_executable
{
    namespace rootswcomponent
    {

        std::atomic_bool SWC_SESL::mRunning(false);

        SWC_SESL::SWC_SESL()
            : mLogger(ara::log::CreateLogger("SESL", "SESL", ara::log::LogLevel::kInfo)),
              m_RPort{nullptr}
        {
            mLogger.LogInfo() << __func__;
            std::signal(SIGTERM, SignalHandler);
        }

        SWC_SESL::~SWC_SESL()
        {
        }

        void
        SWC_SESL::SignalHandler(std::int32_t /*signal*/)
        {
            mRunning = false;
        }

        bool SWC_SESL::Start()
        {
            // mLogger.LogInfo() << __func__;

            mRunning = true;

            if (!setRunningState())
            {
                return false;
            }

            if (!startSESLProxy())
            {
                return false;
            }

            return true;
        }

        void SWC_SESL::Run()
        {
            // mLogger.LogVerbose() << "SWC_SESL::Run";

            while (mRunning)
            {
                std::this_thread::sleep_for(std::chrono::seconds(2));
                m_RPort->RequestSESL_Receive();
            }

            // mLogger.LogVerbose() << "SWC_SESL::RunEnd";
        }

        void SWC_SESL::Terminate()
        {
            // mLogger.LogVerbose() << "SWC_SESL::Terminate";

            // stop running
            mRunning = false;
        }

        bool SWC_SESL::setRunningState()
        {
            ara::exec::ExecutionClient executionClient;
            auto exec = executionClient.ReportExecutionState(ara::exec::ExecutionState::kRunning);
            if (exec.HasValue())
            {
                mLogger.LogInfo() << "SESL app in Running State";
            }
            else
            {
                mLogger.LogError() << exec.Error().Message();
                return false;
            }
            return true;
        }

        bool SWC_SESL::startSESLProxy()
        {
            m_RPort = std::make_shared<sesl_executable::rootswcomponent::port::RPort>();
            m_RPort->Start();
            return true;
        }
    } /// namespace rootswcomponent
} /// namespace sesl_executable

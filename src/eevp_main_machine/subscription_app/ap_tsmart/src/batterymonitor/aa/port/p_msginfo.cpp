///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : p_msginfo.cpp
/// SOFTWARE COMPONENT NAME           : P_MsgInfo
/// GENERATED DATE                    : 2024-08-28 09:41:38
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "batterymonitor/aa/port/p_msginfo.h"
 
namespace batt
{
namespace msginfo
{
namespace skeleton
{
 
P_MsgInfoSkeletonImpl::P_MsgInfoSkeletonImpl(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode)
    : MsgInfoSrvSkeleton(instanceSpec, mode)
    , m_logger(ara::log::CreateLogger("CtxBatteryMonitor", "PORT", ara::log::LogLevel::kVerbose))
{
}
 
} /// namespace skeleton
} /// namespace msginfo
} /// namespace batt

namespace batterymonitor
{
namespace aa
{
namespace port
{
 
P_MsgInfo::P_MsgInfo()
    : m_logger(ara::log::CreateLogger("CtxBatteryMonitor", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
{
}
 
P_MsgInfo::~P_MsgInfo()
{
}
 
void P_MsgInfo::Start()
{
    m_logger.LogVerbose() << "P_MsgInfo::Start";
    
    // construct skeleton
    ara::core::InstanceSpecifier specifier{"BatteryMonitor/AA/P_MsgInfo"};
    m_interface = std::make_shared<batt::msginfo::skeleton::MsgInfoSrvSkeleton>(specifier);
    
    // offer service
    auto offer = m_interface->OfferService();
    if (offer.HasValue())
    {
        m_running = true;
        m_logger.LogVerbose() << "P_MsgInfo::Start::OfferService";
    }
    else
    {
        m_running = false;
        m_logger.LogError() << "P_MsgInfo::Start::OfferService::" << offer.Error().Message();
    }
}
 
void P_MsgInfo::Terminate()
{
    m_logger.LogVerbose() << "P_MsgInfo::Terminate";
    
    // stop port
    m_running = false;
    
    // stop offer service
    m_interface->StopOfferService();
    m_logger.LogVerbose() << "P_MsgInfo::Terminate::StopOfferService";
}
 
void P_MsgInfo::WriteDataems_MsgInfo(const batt::msginfo::skeleton::events::ems_MsgInfo::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    m_ems_MsgInfoData = data;
}

// BCD 인코딩 함수
unsigned char toBCD(int value) {
    return ((value / 10) << 4) | (value % 10);
}
 
void P_MsgInfo::SendEventems_MsgInfoCyclic()
{
    static uint8_t StartFlag_Prev = 0;
    static uint8_t FinishFlag_Prev = 0;

    while (m_running)
    {
        //Start or Finish
        if((StartFlag_Prev == 0 && vStartFlag == 1) ||
           (FinishFlag_Prev == 0 && vFinishFlag == 1) )
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_ems_MsgInfoData.VehicleUniqueSnr = 1;
            if(vStartFlag == 1)
            	m_ems_MsgInfoData.ChargeStatus = 1;
            else if(vFinishFlag == 1)
            	m_ems_MsgInfoData.ChargeStatus = 2;
            m_ems_MsgInfoData.EMS_ConnectionStatus = vEMS_ConnectionStatus;

            // 현재 시간 가져오기
            auto now = std::chrono::system_clock::now();
            std::time_t now_time = std::chrono::system_clock::to_time_t(now);
            std::tm* local_time = std::localtime(&now_time);
            m_ems_MsgInfoData.Date[0] = 0x20;
            m_ems_MsgInfoData.Date[1] = toBCD((local_time->tm_year + 1900) % 100); // 년도의 마지막 두 자리
            m_ems_MsgInfoData.Date[2] = toBCD(local_time->tm_mon + 1);             // 월 (1-12)
            m_ems_MsgInfoData.Date[3] = toBCD(local_time->tm_mday);                // 일 (1-31)
            m_ems_MsgInfoData.Date[4] = toBCD(local_time->tm_hour + 9);            // 시 (0-23)
            if(m_ems_MsgInfoData.Date[4] >= 24) m_ems_MsgInfoData.Date[4] = m_ems_MsgInfoData.Date[4] - 24;
            m_ems_MsgInfoData.Date[5] = toBCD(local_time->tm_min);                 // 분 (0-59)
            m_ems_MsgInfoData.Date[6] = toBCD(local_time->tm_sec);                 // 초 (0-59)

            m_ems_MsgInfoData.BattSOC = vEMS_HVBattSOC;
            m_ems_MsgInfoData.SOH = vEMS_HVBattSOH;
            m_ems_MsgInfoData.SOE = vEMS_HVBattSOE;

            m_ems_MsgInfoData.GetCount = vGetCount;
            m_ems_MsgInfoData.MissedCount = vMissedCount;

            m_ems_MsgInfoData.ChargeStopReason = 3;

            auto send = m_interface->ems_MsgInfo.Send(m_ems_MsgInfoData);
            if (send.HasValue())
            {
                m_logger.LogVerbose() << "<P2> P_MsgInfo::SendEventems_MsgInfoCyclic::Send"<<"\n"
                <<"EMS_ConnectionStatus" << m_ems_MsgInfoData.EMS_ConnectionStatus << "\n"
                <<"BattSOC" <<vEMS_HVBattSOC << "\n"
                <<"SOH"<<m_ems_MsgInfoData.SOH << "\n"
                <<"SOE"<<m_ems_MsgInfoData.SOE << "\n"
                <<"GetCount"<<m_ems_MsgInfoData.GetCount << "\n"
                <<"MissedCount"<<m_ems_MsgInfoData.MissedCount << "\n"
                <<"ChargeStopReason"<<m_ems_MsgInfoData.ChargeStopReason << "\n";
            }
            else
            {
                m_logger.LogVerbose() << "P_MsgInfo::SendEventems_MsgInfoCyclic::Send::" << send.Error().Message();
            }
        }

        StartFlag_Prev = vStartFlag;
        FinishFlag_Prev = vFinishFlag;

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}
 
void P_MsgInfo::SendEventems_MsgInfoTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto send = m_interface->ems_MsgInfo.Send(m_ems_MsgInfoData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "P_MsgInfo::SendEventems_MsgInfoTriggered::Send";
    }
    else
    {
        m_logger.LogVerbose() << "P_MsgInfo::SendEventems_MsgInfoTriggered::Send::" << send.Error().Message();
    }
}
 
void P_MsgInfo::SendEventems_MsgInfoTriggered(const batt::msginfo::skeleton::events::ems_MsgInfo::SampleType& data)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    m_ems_MsgInfoData = data;
    auto send = m_interface->ems_MsgInfo.Send(m_ems_MsgInfoData);
    if (send.HasValue())
    {
        m_logger.LogVerbose() << "P_MsgInfo::SendEventems_MsgInfoTriggered::Send";
    }
    else
    {
        m_logger.LogVerbose() << "P_MsgInfo::SendEventems_MsgInfoTriggered::Send::" << send.Error().Message();
    }
}
 
} /// namespace port
} /// namespace aa
} /// namespace batterymonitor
 
/// EOF